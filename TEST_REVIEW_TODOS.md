# Test Review TODOs
Generated: 2026-02-09
Project: OpenClaw Smart Router (openclaw-router)

## Summary
The test suite is well-structured with 12 test files covering most modules via in-memory SQLite. Unit tests for routing tiers, candidate selection, health checking, budget tracking, and Anthropic stream translation are solid. However, there are critical gaps in error path testing (stream failures always logged as success), a never-cleared rate-limit flag that permanently degrades the system, missing authentication on all endpoints, and duplicate budget tracking logic that has already diverged. The most dangerous finding is that the cost logged after retry uses the *first* candidate's pricing rather than the candidate that actually served the request.

## Critical (fix before next release)

- [ ] **Error Handling** `src/routes/chat-completions.ts:L117` — In the streaming `finally` block, `logRequest()` is called with `success: true` regardless of whether the stream threw an error on L112-114. Every failed streaming request is recorded as successful in `request_log`. **Risk**: Budget tracking, success metrics, and alerting are all incorrect; you cannot distinguish healthy from degraded operation from request_log data. **Action**: Add a `let success = true` flag before the try, set `success = false` in the catch block, and pass it to `logRequest`.

- [ ] **State Management** `src/backends/route-with-retry.ts:L70-78` — `markRateLimited()` sets `is_rate_limited = 1` and `retry_after = datetime('now', '+60 seconds')`, but **nothing in the codebase ever clears this flag**. Once a provider is rate-limited, it stays rate-limited forever until manual DB intervention. `selectCandidates` (L47-53) filters out rate-limited providers on every request. **Risk**: A single transient 429 from Anthropic permanently removes all Anthropic models from routing. **Action**: Add a check in `selectCandidates` or the health check loop that clears `is_rate_limited` when `retry_after < CURRENT_TIMESTAMP`. Write a test that verifies rate limit auto-expiry.

- [ ] **API Contracts** `src/routes/chat-completions.ts:L166-168` — `logRequest()` calculates cost using `decision.candidates?.[0]?.model` (the first-ranked candidate), but `routeWithRetry` may have failed on candidate[0] and succeeded on candidate[1] or [2]. The logged cost, model pricing, and budget tracking all reflect the *wrong model*. **Risk**: Budget tracking accumulates incorrect costs — cloud spend could be systematically under- or over-counted, causing premature budget exhaustion or budget-gate bypass. **Action**: Have `routeWithRetry` return the actual `RankedCandidate` that succeeded (not just `StreamResponse`), and use that candidate's model for cost calculation. Add a test where candidate[0] fails and candidate[1] succeeds, then verify the logged cost matches candidate[1]'s pricing.

- [ ] **Security** `src/routes/chat-completions.ts:L43-44` — The `x-router-source` and `x-router-channel` headers are user-controllable and directly influence Tier 1 rule matching. A client can set `x-router-source: heartbeat` to match the "Heartbeat → self" rule (priority 10) and force-route any request to `local/deepseek-r1-1.5b`, bypassing classification and budget tracking entirely. **Risk**: Intentional or accidental routing bypass; cloud budget circumvention; quality degradation for complex requests. **Action**: Either authenticate the source header against a trusted list, strip it from external requests, or document this as intended behavior. Add a test verifying that spoofed headers produce expected routing (whether that's acceptance or rejection).

## High (address this sprint)

- [ ] **Security** `src/server.ts:L22-30` + all endpoints — No authentication is required on any endpoint. Anyone with network access can send requests (consuming cloud API budget), read full request history via `/stats` (including `request_preview` containing user messages), and list all model configurations via `/v1/models`. **Risk**: Unauthorized cloud API spend; PII exposure via stats endpoint; model infrastructure enumeration. **Action**: Add at minimum a bearer token check (e.g., `ROUTER_API_KEY` env var) on all routes. Write tests for 401 responses on unauthenticated requests.

- [ ] **State Management** `src/router/candidate-select.ts:L121-137` vs `src/health/budget-tracker.ts:L52-74` — There are two independent `isBudgetExceeded` implementations. The one in `candidate-select.ts` is a private function; the one in `budget-tracker.ts` is exported. They have the same logic today but are not tested for consistency and could diverge. **Risk**: Budget gating behavior differs between candidate selection and health endpoint reporting. **Action**: Remove the private `isBudgetExceeded` from `candidate-select.ts` and import the one from `budget-tracker.ts`. Add a test that both code paths agree on exceeded/not-exceeded state.

- [ ] **Resource Management** `src/backends/openai-backend.ts:L90-126` + `src/backends/anthropic-backend.ts:L137-179` — Both SSE stream parsers acquire a `ReadableStream` reader but if the consuming async generator is abandoned (e.g., client disconnects mid-stream), the reader lock is never released and the underlying TCP connection may hang. The `abort()` function returned in `StreamResponse` is never called by `chat-completions.ts`. **Risk**: Connection leak under client disconnects; eventual file descriptor exhaustion under load. **Action**: In `chat-completions.ts`, listen for `request.raw.on('close')` and call `streamResponse.abort()`. Add a test that simulates client disconnect and verifies the abort signal fires.

- [ ] **Error Handling** `src/backends/route-with-retry.ts:L19-31` — Backend errors that are neither 429 nor timeout (e.g., 500, 502, 503, auth failures) are caught and retried to the next candidate, but the failed model is **not marked unhealthy or rate-limited**. Repeated 500s from a backend will be silently retried every request without any feedback to the health system. **Risk**: Hot loop of failed requests to a consistently-broken backend with no circuit-breaking. **Action**: Consider marking models unhealthy after N consecutive non-429 errors (similar to health check threshold). Add tests for 500/502 error handling paths.

- [ ] **Observability** `src/routes/chat-completions.ts:L156-219` — `logRequest` always logs `success: 1` (line 162 hardcodes `true`). There is no code path that sets `success = false`. The function signature accepts a `success` parameter but the caller never passes `false`. Combined with the streaming bug above, 100% of requests appear successful in `request_log`. **Risk**: Complete inability to monitor error rates from the database. **Action**: In the non-streaming path, wrap the chunk collection in try/catch and log `success: false` on error. Verify with tests that failed backend responses produce `success: 0` in request_log.

## Medium (tech debt backlog)

- [ ] **Performance** `src/health/health-checker.ts:L59-71` — `checkAllModels` pings models sequentially. With 9 models at 5s timeout each, a full check cycle could take 45s, nearly exhausting the default 60s interval. **Risk**: Health checks overlap or leave insufficient headroom as more models are added. **Action**: Use `Promise.allSettled()` to run health pings in parallel (or with a concurrency limit). Add a test measuring that check completion time scales sub-linearly with model count.

- [ ] **Input Validation** `src/routes/chat-completions.ts:L24-45` — The request body is cast via `as ChatCompletionsBody` without runtime validation. A message with `role: 123` or `content: [1,2,3]` would pass the `Array.isArray(body.messages)` check and be forwarded to backends verbatim. **Risk**: Malformed requests could crash backends or produce undefined behavior. **Action**: Add schema validation via Fastify's built-in JSON Schema support or a zod schema. Add tests with malformed message objects (wrong types, missing fields).

- [ ] **Input Validation** `src/router/tier1-rules.ts:L57-65` — Routing rules with `match_pattern` use `new RegExp(rule.match_pattern, 'i')` on each request. Complex patterns stored in DB (e.g., via admin insertion) could cause ReDoS (catastrophic backtracking). **Risk**: A single malicious or carelessly-written regex in `routing_rules` could hang the event loop and DoS the server. **Action**: Use a regex timeout (e.g., `re2` library) or pre-validate pattern complexity at insertion time. Add a test with a known ReDoS pattern verifying it doesn't block for >100ms.

- [ ] **Performance** `src/router/tier1-rules.ts:L25-29` — All enabled rules are loaded from SQLite on every single request (`SELECT * FROM routing_rules WHERE is_enabled = 1`). While SQLite is fast, this query is repeated on every chat completion, and rules are static between admin changes. **Risk**: Unnecessary per-request DB overhead; linear slowdown as rule count grows. **Action**: Cache rules in memory with a TTL or invalidation mechanism. Add a benchmark test verifying routing latency stays under 1ms for 100+ rules.

- [ ] **Resource Management** — Tables `model_health_log` and `request_log` grow without bound. There is no cleanup, rotation, or archival. **Risk**: SQLite DB file grows indefinitely; query performance degrades as tables grow; disk exhaustion. **Action**: Add a periodic cleanup job (e.g., delete health logs older than 7 days, request logs older than 30 days). Add a test verifying that cleanup preserves recent entries while removing old ones.

- [ ] **Error Handling** `src/routes/chat-completions.ts:L119-152` — Non-streaming response assembly (`chunks.map(c => c.choices?.[0]?.delta?.content ?? '').join('')`) doesn't handle the case where `chunks` is empty (all chunks failed to parse). `lastChunk` would be `undefined`, and the response would contain `id: undefined`, `created: undefined`. **Risk**: Malformed response sent to client on empty chunk array. **Action**: Add a guard for empty chunks array returning a 502. Add a test where the backend returns no parseable chunks.

- [ ] **Configuration** `Dockerfile:L51` vs `.env.example:L2` — Docker EXPOSE is port 3000, docker-compose sets `ROUTER_PORT=3000`, but `.env.example` defaults to `ROUTER_PORT=8080` and `config.ts:L23` defaults to `8080`. **Risk**: Confusion on deployment; container health check hits port 3000 but app might listen on 8080 if `.env` isn't loaded. **Action**: Align default port across all config sources, or document the expected override chain. Add a config test that verifies port resolution with and without env vars.

- [ ] **API Contracts** `src/backends/anthropic-backend.ts:L54` — Anthropic API version is hardcoded to `'2023-06-01'`. **Risk**: As Anthropic evolves their API, this pinned version may miss features or encounter deprecation. **Action**: Make the API version configurable or update to current. Not a test gap per se, but a hardening TODO.

## Low (hardening)

- [ ] **Observability** All source files — Fastify's pino logger is configured (`logger: true` in server.ts) but never used in route handlers, backends, or health checks. All logging uses bare `console.error`/`console.log` which bypasses Fastify's structured logging, log levels, and request correlation. **Risk**: No structured logging in production; no log level filtering; cannot correlate logs to specific requests. **Action**: Pass the Fastify logger instance (`request.log` or `app.log`) to route handlers and use it instead of console. Not directly testable, but improves operability.

- [ ] **Security** `src/routes/chat-completions.ts:L179` — `request_preview` stores up to 200 chars of the user's last message in `request_log`. The `/stats` endpoint (L52-57) returns recent requests including this field without redaction. **Risk**: PII/sensitive content persisted in DB and exposed via unauthenticated endpoint. **Action**: Either redact `request_preview` in stats output, truncate more aggressively, or make it opt-in. Add a test that sensitive content in a request is not returned verbatim from /stats.

- [ ] **Error Handling** `src/router/router.ts:L37-39` — Media detection uses regex `/\[image\]|\[file\]|\[attachment\]/i` on string message content. This would false-positive on messages like "Put the [file] in the folder" or "Click on [image] above". **Risk**: Incorrect `has_media` flag → wrong routing rule match → suboptimal model selection. **Action**: Only detect media from structured content (array-type `content` field with `image_url` entries), not regex on strings. Add a test with literal text containing "[image]" verifying it doesn't trigger media detection.

- [ ] **State Management** `src/router/candidate-select.ts:L99-116` — `applyQualityTolerance` returns `strict` (empty array) when no strict or soft matches exist (L115). This is correct but the variable name is misleading — returning an empty `strict` array after it was already checked suggests a potential future refactor could mistake this for a populated list. **Risk**: Low — logic is correct today. **Action**: Return `[]` explicitly on L115 instead of `strict` for clarity. Add a test verifying that quality tolerance returns empty when no models are within tolerance range.

- [ ] **Distributed Systems** `src/health/health-checker.ts:L62-64` — Health check pings `GET /models` endpoint which only verifies HTTP connectivity, not actual inference capability. A model could respond to /models but fail on /chat/completions (OOM, GPU error). **Risk**: Models reported as healthy when inference is broken. **Action**: Consider a lightweight inference ping (e.g., single-token completion) as an optional deep health check. Add a test that verifies health check actually distinguishes between responsive and unresponsive endpoints.

- [ ] **Performance** `src/router/candidate-select.ts:L72-85` — Sort comparator computes `a.cost_input + a.cost_output` on every comparison. For large candidate lists this is negligible, but a pre-computed sort key would be cleaner. **Risk**: Negligible. **Action**: Pre-compute total cost before sorting. Low priority.

## Observations

- **Rate limiting is write-only**: The system marks providers as rate-limited but never auto-clears the flag. This is the most architecturally concerning gap — it creates a one-way ratchet toward degraded service.
- **Cost tracking uses wrong model**: The `logRequest` function in chat-completions.ts calculates cost from `candidates[0]` rather than the model that actually served the request (which may be candidates[1] or later after retries). This silently corrupts budget data.
- **Duplicate code for budget checking**: `isBudgetExceeded` exists in both `candidate-select.ts` (private) and `budget-tracker.ts` (exported), creating a maintenance hazard.
- **No auth anywhere**: All endpoints are completely unauthenticated, including the stats endpoint that exposes user message content. This is acceptable for local dev but dangerous if exposed beyond localhost.
- **Tests only cover happy-path streaming**: Streaming tests verify correct SSE output but don't test client disconnect, mid-stream errors, or backend returning invalid SSE. The `success` flag is never tested as `false`.
- **globalThis.fetch mocking pattern is fragile**: Multiple test files mock `globalThis.fetch` and restore it manually in each test, without using `vi.stubGlobal` or `afterEach` cleanup — a thrown assertion before restore would leak the mock to subsequent tests.
- **No test for the /stats endpoint in isolation**: The stats endpoint is only tested via `integration.test.ts`; there are no unit tests for edge cases (empty DB, malformed data, large result sets).
